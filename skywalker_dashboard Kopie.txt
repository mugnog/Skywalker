import streamlit as st
import pandas as pd
import plotly.express as px
import re
import xml.etree.ElementTree as ET
from datetime import datetime
from dotenv import load_dotenv
from google import genai
import os
from streamlit_autorefresh import st_autorefresh



# =====================================================
# 0. DESIGN-UPGRADE & GRUNDSETUP
# =====================================================
load_dotenv()

# WICHTIG: Die Page Config muss vor dem ersten CSS-Block stehen
st.set_page_config(page_title="Skywalker Fitness Dashboard", layout="wide")

# Hier kommt das CSS f√ºr die gro√üen Tabs und den fetten Balken hin
st.markdown("""
    <style>
    /* 1. Schriftgr√∂√üe der Tabs oben massiv vergr√∂√üern */
    button[data-baseweb="tab"] p {
        font-size: 26px !important; 
        font-weight: 800 !important;
        margin-bottom: 0px;
    }

    /* 2. Den FTP-Balken (Progress Bar) richtig fett machen */
    .stProgress > div > div > div > div {
        height: 45px !important; /* Sehr dick */
        border-radius: 12px !important;
        background-image: linear-gradient(to right, #00C853, #b2ff59) !important;
    }
    
    /* Hintergrund des Balkens */
    .stProgress > div > div {
        background-color: #262626 !important;
        height: 45px !important;
        border-radius: 12px !important;
    }

    /* Farbe f√ºr den aktiven Tab (Gr√ºn) */
    button[data-baseweb="tab"][aria-selected="true"] p {
        color: #00C853 !important;
    }
    </style>
""", unsafe_allow_html=True)

API_KEY = os.getenv("GOOGLE_API_KEY")
SAVE_PATH = os.getenv("SAVE_PATH")

if not API_KEY:
    st.error("GOOGLE_API_KEY fehlt in der .env")
    st.stop()

if not SAVE_PATH:
    st.error("SAVE_PATH fehlt in der .env")
    st.stop()


# =====================================================
# 1. GEMINI SETUP
# =====================================================
client = genai.Client(api_key=os.getenv("GOOGLE_API_KEY"))

# =====================================================
# 2. DATEIPFADE
# =====================================================
FILE_STATS = os.path.join(SAVE_PATH, "garmin_stats.csv")
FILE_ACT = os.path.join(SAVE_PATH, "garmin_activities.csv")
FILE_CHECKIN = os.path.join(SAVE_PATH, "daily_checkin.csv")


def manual_data_upload():
    st.sidebar.header("üì• Daten-Import")
    uploaded_file = st.sidebar.file_uploader("Garmin CSV-Export hochladen", type=["csv"])

    if uploaded_file is not None:
        try:
            df_new = pd.read_csv(uploaded_file)
            
            # Check: Sind es Schlafdaten oder Aktivit√§ten?
            if "Sleep Score" in df_new.columns or "Schlafwert" in df_new.columns:
                target_file = FILE_STATS
                st.sidebar.success("Schlafdaten erkannt!")
            else:
                target_file = FILE_ACT
                st.sidebar.success("Aktivit√§t erkannt!")

            # Daten zusammenf√ºhren
            if os.path.exists(target_file):
                df_old = pd.read_csv(target_file)
                df_final = pd.concat([df_new, df_old]).drop_duplicates(subset=["Date"], keep="first")
                df_final.to_csv(target_file, index=False)
                st.sidebar.info("Daten wurden aktualisiert!")
                st.rerun()
                
        except Exception as e:
            st.sidebar.error(f"Fehler beim Lesen: {e}")

# In deiner Haupt-App rufst du das dann einfach so auf:
manual_data_upload()



# =====================================================
# 3. DATEN LADEN
# =====================================================
@st.cache_data(ttl=60)
def load_all_data():
    df_s = pd.read_csv(FILE_STATS) if os.path.exists(FILE_STATS) else None
    df_a = pd.read_csv(FILE_ACT) if os.path.exists(FILE_ACT) else None
    df_c = pd.read_csv(FILE_CHECKIN) if os.path.exists(FILE_CHECKIN) else None

    if df_s is not None:
        df_s["Date"] = pd.to_datetime(df_s["Date"])
        df_s["Sleep_num"] = pd.to_numeric(df_s["Sleep Score"], errors="coerce")
        df_s["RHR_num"] = pd.to_numeric(df_s["RHR"], errors="coerce")
        df_s["Steps_num"] = pd.to_numeric(df_s["Steps"], errors="coerce")

    if df_a is not None:
        df_a["Date"] = pd.to_datetime(df_a["Date"])
        if "distance" in df_a.columns:
            df_a["KM"] = (pd.to_numeric(df_a["distance"], errors="coerce") / 1000).round(2)

    if df_c is not None:
        df_c["Date"] = pd.to_datetime(df_c["Date"])

    return df_s, df_a, df_c

df_stats, df_act, df_checkin = load_all_data()


# =====================================================
# ZENTRALE PERFORMANCE-BERECHNUNG (Inkl. FTP-Sch√§tzung Fix)
# =====================================================
curr_ctl, curr_atl, curr_tsb, weekly_load = 0, 0, 0, 0
est_ftp = 230  # Standardwert als Fallback

if df_act is not None and not df_act.empty:
    df_perf = df_act.copy()
    df_perf['Date'] = pd.to_datetime(df_perf['Date'])
    
    # Wir nehmen die Daten (iloc[1:] √ºberspringt die Einheiten-Zeile)
    df_data = df_perf.iloc[1:].copy()
    
    # --- 1. FTP SCH√ÑTZUNG (JETZT GANZ OBEN BERECHNET) ---
    thirty_days_ago = pd.Timestamp.now() - pd.Timedelta(days=30)
    recent_acts = df_data[df_data['Date'] >= thirty_days_ago].copy()
    recent_acts['normPower'] = pd.to_numeric(recent_acts['normPower'], errors='coerce')
    
    if not recent_acts.empty and recent_acts['normPower'].max() > 0:
        est_ftp = int(recent_acts['normPower'].max() * 0.95)

    # --- 2. WOCHEN-LOAD BERECHNEN ---
    df_data['Load'] = pd.to_numeric(df_data['activityTrainingLoad'], errors='coerce').fillna(0)
    one_week_ago = pd.Timestamp.now() - pd.Timedelta(days=7)
    weekly_load = round(df_data[df_data['Date'] >= one_week_ago]['Load'].sum(), 1)
    
    # --- 3. CTL/ATL/TSB BERECHNUNG ---
    daily_load = df_data.groupby('Date')['Load'].sum().reset_index()
    if not daily_load.empty:
        idx = pd.date_range(daily_load['Date'].min(), pd.Timestamp.now())
        daily_load = daily_load.set_index('Date').reindex(idx, fill_value=0).reset_index()
        daily_load.columns = ['Date', 'Load']
        
        daily_load['ATL'] = daily_load['Load'].ewm(span=7, adjust=False).mean()
        daily_load['CTL'] = daily_load['Load'].ewm(span=42, adjust=False).mean()
        daily_load['TSB'] = daily_load['CTL'].shift(1) - daily_load['ATL'].shift(1)
        
        curr_ctl = round(daily_load['CTL'].iloc[-1], 1)
        curr_atl = round(daily_load['ATL'].iloc[-1], 1)
        curr_tsb = round(daily_load['TSB'].iloc[-1] if not pd.isna(daily_load['TSB'].iloc[-1]) else 0, 1)


# =====================================================
# 4. ZWO VALIDATOR (REPARATUR-MODUS)
# =====================================================
def validate_zwo(xml_string: str):
    try:
        # 1. Reinigung: Alles vor <workout_file> und nach </workout_file> entfernen
        if "<workout_file>" in xml_string:
            xml_string = xml_string[xml_string.find("<workout_file>"):]
        if "</workout_file>" in xml_string:
            xml_string = xml_string[:xml_string.find("</workout_file>") + 15]

        # 2. Parsen des KI-Outputs
        root = ET.fromstring(xml_string)
        
        # 3. Architektur-Neuaufbau nach deinem Muster
        # Wir erstellen ein komplett neues Element-Baum-Objekt
        new_root = ET.Element("workout_file")
        
        # Feste Reihenfolge der Tags wie in deinem Beispiel
        ET.SubElement(new_root, "author").text = "D.Mugnog"
        
        name_val = root.findtext("name") or "Skywalker Workout"
        ET.SubElement(new_root, "name").text = name_val
        
        desc_val = root.findtext("description") or ""
        ET.SubElement(new_root, "description").text = desc_val
        
        ET.SubElement(new_root, "sportType").text = "bike"
        ET.SubElement(new_root, "tags") # Erzeugt <tags/>
        
        # Workout-Bereich aufbauen
        workout_node = root.find("workout")
        new_workout = ET.SubElement(new_root, "workout")

        if workout_node is not None:
            for child in workout_node:
                # Wir √ºbernehmen den Typ (Warmup, SteadyState, etc.)
                # Aber wir korrigieren die Attribute auf dein Format (Gro√üschreibung + pace)
                new_attrs = {}
                for k, v in child.attrib.items():
                    kl = k.lower()
                    if kl == "duration": new_attrs["Duration"] = v
                    elif kl == "power": new_attrs["Power"] = v
                    elif kl == "powerlow": new_attrs["PowerLow"] = v
                    elif kl == "powerhigh": new_attrs["PowerHigh"] = v
                    elif kl == "cadence": new_attrs["cadence"] = v # Optional, falls vorhanden
                
                # pace="0" immer hinzuf√ºgen
                new_attrs["pace"] = "0"
                
                # Neues Element mit sauberen Attributen einf√ºgen
                ET.SubElement(new_workout, child.tag, new_attrs)

        # 4. Export ohne XML-Header
        # encoding="unicode" sorgt daf√ºr, dass <?xml...?> weggelassen wird
        final_xml = ET.tostring(new_root, encoding="unicode", method="xml")
        
        return True, "OK", final_xml

    except Exception as e:
        return False, str(e), xml_string

# =====================================================
# 5. PROMPT
# =====================================================
heute_str = datetime.now().strftime("%A, %d.%m.%Y")
BASE_PROMPT = """
Du bist "Skywalker", ein professioneller Coach. 
Nutzer: 52 Jahre, Chirurg, Ziel FTP 250, Fokus Di/Mi und Fr-So.

WICHTIGE REGEL F√úR DEINE ANALYSE:
1. Priorit√§t (70% Gewichtung): Nutze die Garmin-Daten. Das sind die Fakten.
2. Priorit√§t (30% Gewichtung): Nutze das subjektive Daily Check-in als Erg√§nzung.

Regeln: Einfaches Deutsch, kein Smalltalk, nur XML bei Workouts.
"""

# =====================================================
# 6. UI HEADER
# =====================================================
st.title("üöÄ Skywalker Fitness Dashboard")

if df_stats is not None:
    c1, c2, c3, c4 = st.columns(4)
    with c1:
        s = df_stats.dropna(subset=["Sleep_num"]).sort_values("Date")
        st.metric("Letzter Schlaf", int(s.iloc[-1]["Sleep_num"]) if not s.empty else 0)
    with c2:
        a = df_act.dropna(subset=["activityTrainingLoad"]) if df_act is not None else pd.DataFrame()
        st.metric("Letzter Load", round(a.iloc[-1]["activityTrainingLoad"], 1) if not a.empty else 0)
    with c3:
        r = df_stats.dropna(subset=["RHR_num"]).sort_values("Date")
        st.metric("Ruhepuls", int(r.iloc[-1]["RHR_num"]) if not r.empty else 0)
    with c4:
        st.metric("Schritte", int(df_stats.iloc[-1]["Steps_num"]) if df_stats is not None else 0)

# =====================================================
# 7. TABS
# =====================================================
tab1, tab2, tab3, tab4, tab5 = st.tabs(["ü§ñ Coach", "üö¥ Aktivit√§ten", "üò¥ Schlaf", "üèÉ Schritte", "üìà Trends"])




# =====================================================
# TAB 1 ‚Äì SKYWALKER COACH & AGENTEN-LOGIK
# =====================================================

with tab1:
    st.subheader("ü§ñ Skywalker AI Coaching Netzwerk")
    
# --- PERFORMANCE HEADER (Jetzt mit 4 Spalten) ---
    c_m1, c_m2, c_m3, c_m4 = st.columns(4)
    
    # 1. Spalte: Fitness (CTL)
    c_m1.metric("Fitness (CTL)", curr_ctl, help="Dein 42-Tage-Durchschnitt. Ziel: Langsam steigern.")
    
    # 2. Spalte: Erm√ºdung (ATL)
    c_m2.metric("Erm√ºdung (ATL)", curr_atl, help="Dein 7-Tage-Durchschnitt. Vorsicht bei schnellen Spr√ºngen.")
    
    # 3. Spalte: Form (TSB) mit Status-Logik
    if curr_tsb < -25:
        tsb_status = "üî¥ √úberlastet"
        tsb_color = "inverse"
    elif curr_tsb < -10:
        tsb_status = "üü° Produktiv"
        tsb_color = "normal"
    elif curr_tsb > 5:
        tsb_status = "üü¢ Erholt / Peak"
        tsb_color = "normal"
    else:
        tsb_status = "‚öñÔ∏è Neutral"
        tsb_color = "off"
        
    c_m3.metric("Form (TSB)", curr_tsb, delta=tsb_status, delta_color=tsb_color)
    
    # 4. Spalte: Wochen-Load (Dein neues Feature)
    # Zeigt die Summe der Load-Punkte der letzten 7 Tage
    c_m4.metric("Wochen-Load", weekly_load, help="Gesamter Trainingsload der letzten 7 Tage.")

    st.divider()

# --- DAILY CHECK-IN SEKTION (CHIRURGEN-LOGIK 4+4) ---
    st.markdown("### üìù Daily Check-in")
    c_date = st.date_input("Datum f√ºr den Check-in", datetime.now(), key="checkin_date_picker")
    c_date_pure = c_date.strftime("%Y-%m-%d")
    
    st.markdown("""
        <style>
        div[data-baseweb="slider"] > div:first-child > div:first-child {
            height: 12px !important; border-radius: 6px !important;
            background: linear-gradient(to right, #D50000, #FFD600, #00C853) !important;
            border: 1px solid #444 !important;
        }
        div[data-baseweb="slider"] [role="slider"] {
            background-color: white !important; border: 3px solid #555 !important;
            width: 22px !important; height: 22px !important;
        }
        </style>
    """, unsafe_allow_html=True)

    col_left, col_right = st.columns(2)
    
    with col_left:
        s1 = st.slider("Schlafqualit√§t", 1, 10, 7, help="10 = Perfekt erholt")
        
        # Stress-Freiheit (10 ist entspannt/gr√ºn)
        s2_val = st.slider("Entspannung (Arbeitsstress)", 1, 10, 8, help="10 = Kein Stress / Entspannt (Gr√ºn)")
        s2 = 11 - s2_val 
        
        s3 = st.slider("Physische Energie", 1, 10, 8, help="Hast du Kraft in den Beinen? 10 = Volle Power")
        
        s_load = st.slider("Belastung gestern", 1, 10, 5, help="Wie hart war der Reiz gestern?")

    with col_right:
        s4 = st.slider("Muskelzustand", 1, 10, 8, help="10 = Keine Schmerzen / Locker")
        s5 = st.slider("Ern√§hrung & Hydration", 1, 10, 7, help="Speicher voll?")
        s6 = st.slider("Mentale Frische", 1, 10, 7, help="Fokus f√ºr Intervalle?")
        
        s_health = st.slider("Gesundheits-Gef√ºhl", 1, 10, 10, 
                             help="Kratzen im Hals? Krankheitsanzeichen? 10 = Kerngesund (Gr√ºn)")

    if st.button("Check-in f√ºr Skywalker speichern"):
        # Wir speichern hier 9 Werte (Datum + 8 Slider)
        new_data = [[c_date_pure, s1, s2, s3, s_load, s4, s5, s6, s_health]]
        new_columns = ["Date", "Schlaf", "Stress", "Energie", "Load_Gestern", "Muskeln", "Ernahrung", "Mental", "Gesundheit"]
        
        new_checkin = pd.DataFrame(new_data, columns=new_columns)
        
        if os.path.exists(FILE_CHECKIN):
            # Anh√§ngen ohne Header
            new_checkin.to_csv(FILE_CHECKIN, mode='a', header=False, index=False)
        else:
            # Neue Datei erstellen mit Header
            new_checkin.to_csv(FILE_CHECKIN, index=False)
        
        st.success(f"Check-in f√ºr {c_date_pure} gespeichert. Die neue Datei wurde erstellt!")
        # Seite neu laden, damit die Historie sofort aktualisiert wird
        st.rerun()

    st.divider()


    # --- DATEN-KONTEXT F√úR DIE AGENTEN ---
    # Hier ziehen wir die Power-Daten aus der garmin_activities.csv
    heute_jetzt = datetime.now().strftime("%A, %d.%m.%Y")
    garmin_perf_ctx = "KEINE LEISTUNGSDATEN GEFUNDEN"
    if df_act is not None:
        cols = ["Date", "activityName", "avgPower", "normPower", "averageHR", "activityTrainingLoad"]
        available_cols = [c for c in cols if c in df_act.columns]
        # iloc[1:51] √ºberspringt Parameterzeile und nimmt 50 Aktivit√§ten
        garmin_perf_ctx = df_act[available_cols].iloc[1:51].to_string(index=False)
    
    garmin_stats_ctx = "KEINE GESUNDHEITSDATEN"
    if df_stats is not None:
        garmin_stats_ctx = df_stats.iloc[1:15].to_string(index=False)

    checkin_hist = "KEIN CHECK-IN VORHANDEN"
    if os.path.exists(FILE_CHECKIN):
        checkin_hist = pd.read_csv(FILE_CHECKIN).tail(7).to_string(index=False)

# --- VERFEINERTER AGENTEN-PROMPT (75/25 GEWICHTUNG & 8-PUNKTE-PROFIL) ---
    # Vorbereitung der Werte
    base_ftp = 230
    effective_ftp = max(base_ftp, est_ftp)

    # --- DER DUALE FTP-PROMPT ---
    DYNAMIC_PROMPT = f"""
    {BASE_PROMPT}
    HEUTE IST: {heute_jetzt}
    

    ANWEISUNG F√úR DIE PLANUNG:
    - Erstelle alle Pl√§ne und XML-Workouts EXKLUSIV auf Basis von {base_ftp}W.
    - Die Garmin-Sch√§tzung dient nur als Referenz f√ºr die aktuelle Formkurve.
    
    DEINE ENTSCHEIDUNGS-MATRIX (WICHTIG):
    1. PRIORITY (75% Gewichtung): Garmin-Daten. Analysiere CTL ({curr_ctl}), ATL ({curr_atl}) und TSB ({curr_tsb}) sowie HRV-Trends und Ruhepuls.
    2. CONTEXT (25% Gewichtung): Daily Check-in. Nutze die subjektiven Werte als Korrektiv.

    DATEN-KONTEXT F√úR DIE AGENTEN:
    - Garmin Gesundheit (HRV/Schlaf/RHR): {garmin_stats_ctx}
    - Garmin Leistung (NP/Power/TSS): {garmin_perf_ctx}
    - Subjektives Gef√ºhl (Check-in heute): 
      Schlaf: {s1}/10, Stress: {s2}/10, Physische Energie: {s3}/10, Belastung Gestern: {s_load}/10
      Muskeln: {s4}/10, Ern√§hrung: {s5}/10, Mentaler Fokus: {s6}/10, Gesundheit: {s_health}/10
    - Check-in Historie (letzte 7 Tage): {checkin_hist}
    
    DEINE AGENTEN-ROLLEN:
    1. ANALYSE-AGENT: Bewerte die Form. Passt das Gesundheits-Gef√ºhl ({s_health}/10) zu den Garmin-Werten?
    2. PLANUNGS-AGENT: Erstelle den Plan 
       - Ziel: FTP 250W. Aktuelle Sch√§tzung: {est_ftp}W. Aber gemessener: ftp base_ftp = 230
       - Regel: Wenn Gesundheit < 7 oder Stress > 7, Intensit√§t reduzieren.
       - Regel: Wenn TSB > 0 und Energie > 7, pushen wir Richtung 250W.
    3. VALIDIERUNGS-AGENT: Garantiere physiologische Logik.

    ANWEISUNG: Antworte als Skywalker. Kurz, pr√§zise, chirurgisch. 
    Struktur: 'ANALYSE', 'PLAN' & 'FTP-SCH√ÑTZUNG'.
    3. Erstelle am Ende GENAU EIN XML-Workout. 
    WICHTIG: Starte direkt mit <workout_file>. 
    Lasse die Zeile <?xml version="1.0" encoding="UTF-8"?> UNBEDINGT weg! 
    Nutze daf√ºr ausschlie√ülich das Format <workout_file>...</workout_file>. 
    Erstelle das Workout mit einfachen SteadyState-Bl√∂cken. Nutze Gro√üschreibung f√ºr Duration und Power.
    Schreibe im Text-Teil davor kurz, was heute zu tun ist.
    """


    # --- COACHING AKTIONEN ---
    mock_mode = st.checkbox("Mock-Modus aktivieren", value=False)
    
    if "last_answer" not in st.session_state:
        st.session_state.last_answer = ""
    
    b1, b2, b3 = st.columns(3)
    q1, q2, q3 = b1.button("üìä Profi-Analyse"), b2.button("üìÖ 5-Tage-Plan"), b3.button("üõãÔ∏è Erholungstipps")
    
    user_text = st.text_input("Eigene Frage an das Skywalker Netzwerk")
    send = st.button("Senden")

    final_query = ""
    if q1: final_query = "F√ºhre eine Agenten-Analyse meiner aktuellen Form durch."
    elif q2: final_query = "Erstelle einen 5-Tage-Periodisierungsplan inklusive heutigem XML."
    elif q3: final_query = "Berechne basierend auf ATL/TSB eine optimale Erholungsstrategie."
    elif user_text and send: final_query = user_text

    if final_query:
        if mock_mode:
            st.session_state.last_answer = "Skywalker Agenten-Netzwerk: (Mock) Analyse abgeschlossen."
        else:
            with st.spinner("Das Skywalker Agenten-Netzwerk analysiert alle Datenpunkte..."):
                try:
                    response = client.models.generate_content(
                        model="models/gemini-2.0-flash", 
                        contents=f"{DYNAMIC_PROMPT}\n\nANFRAGE: {final_query}"
                    )
                    st.session_state.last_answer = response.text
                except Exception as e:
                    st.error(f"Agenten-Fehler: {e}")

# --- DER FINALE SKYWALKER FEEDBACK-BLOCK (KEINE DOPPLUNG) ---
if st.session_state.last_answer:
    st.info("ü§ñ Skywalkers Coaching-Feedback")
    
    raw_text = st.session_state.last_answer
    xml_pattern = r"(<workout_file>.*?</workout_file>)"
    
    # 1. Text ohne XML f√ºr die Anzeige s√§ubern
    clean_display_text = re.sub(xml_pattern, "", raw_text, flags=re.DOTALL)
    lines = [line.strip() for line in clean_display_text.split('\n') if line.strip()]
    
    # Textanzeige (Passiert hier nur genau EINMAL)
    st.markdown("\n\n".join(lines))
    
    # 2. XML extrahieren und f√ºr Zwift vorbereiten
    xml_match = re.search(xml_pattern, raw_text, re.DOTALL)
    
    if xml_match:
        raw_xml = xml_match.group(1)
        valid, msg, final_xml = validate_zwo(raw_xml)
        
        if valid:
            # Workout-Namen sicher f√ºr Dateisystem extrahieren
            try:
                root = ET.fromstring(final_xml)
                workout_name_tag = root.find("name")
                workout_name_text = workout_name_tag.text if workout_name_tag is not None else "Skywalker_Workout"
                
                # Extrem sicherer Dateiname (keine Bindestriche, nur Buchstaben/Zahlen)
                safe_name = re.sub(r'[^a-zA-Z0-9\s]', '', workout_name_text)
                clean_name = safe_name.strip().replace(' ', '_')
            except Exception as e:
                clean_name = f"Skywalker_Plan_{c_date_pure}"
                workout_name_text = "Skywalker Workout"

            st.divider()
            st.success(f"üöÄ Workout '{workout_name_text}' ist bereit!")
            
            st.download_button(
                label=f"üì• {clean_name}.zwo herunterladen",
                data=final_xml,
                file_name=f"{clean_name}.zwo",
                mime="application/xml",
                key="agent_workout_download"
            )
        else:
            st.warning(f"Das Workout hat einen Fehler: {msg}")
            with st.expander("Rohdaten f√ºr Profis"):
                st.code(raw_xml, language="xml")

# --- TAB 2 bis 5 (Bleiben identisch) ---
with tab2:
    if df_act is not None:
        st.dataframe(df_act.sort_values("Date", ascending=False).head(20), width='stretch')

with tab3:
    if df_stats is not None:
        df_sleep = df_stats.dropna(subset=["Sleep_num"]).tail(90)
        if not df_sleep.empty:
            fig_sleep = px.area(df_sleep, x="Date", y="Sleep_num", color_discrete_sequence=['#00f2ff'])
            fig_sleep.update_layout(yaxis=dict(range=[0, 105]), plot_bgcolor='rgba(0,0,0,0)', paper_bgcolor='rgba(0,0,0,0)')
            st.plotly_chart(fig_sleep, width='stretch')

with tab4:
    if df_stats is not None:
        fig_steps = px.bar(df_stats.tail(30), x="Date", y="Steps_num", color_discrete_sequence=['#39FF14'], text_auto='.2s')
        fig_steps.update_layout(plot_bgcolor='rgba(0,0,0,0)', paper_bgcolor='rgba(0,0,0,0)')
        st.plotly_chart(fig_steps, width='stretch')

# =====================================================
# TAB 5 ‚Äì TRENDS & PERFORMANCE (CTL/ATL/TSB)
# =====================================================
with tab5:
    st.header("üìà Performance Management (CTL / ATL / TSB)")
    
    if df_act is not None and not df_act.empty:
        # 1. Daten f√ºr Performance-Metriken vorbereiten
        df_perf = df_act.copy()
        df_perf['Date'] = pd.to_datetime(df_perf['Date'])
        df_perf['activityTrainingLoad'] = pd.to_numeric(df_perf['activityTrainingLoad'], errors='coerce').fillna(0)
        
        # T√§gliche Last aggregieren
        daily_load = df_perf.groupby('Date')['activityTrainingLoad'].sum().reset_index()
        
        # Zeitreihe l√ºckenlos machen
        idx = pd.date_range(daily_load['Date'].min(), daily_load['Date'].max())
        daily_load = daily_load.set_index('Date').reindex(idx, fill_value=0).reset_index()
        daily_load.columns = ['Date', 'Load']
        
        # 2. CTL, ATL und TSB berechnen
        daily_load['ATL'] = daily_load['Load'].ewm(span=7, adjust=False).mean()
        daily_load['CTL'] = daily_load['Load'].ewm(span=42, adjust=False).mean()
        daily_load['TSB'] = daily_load['CTL'].shift(1) - daily_load['ATL'].shift(1)
        
        # 3. Gro√ües Performance Chart
        fig_perf = px.line(daily_load.tail(90), x='Date', y=['CTL', 'ATL'], 
                           title="Fitness (CTL) vs. Erm√ºdung (ATL) - Letzte 90 Tage",
                           labels={'value': 'Training Stress', 'variable': 'Metrik'},
                           color_discrete_map={'CTL': '#00FF00', 'ATL': '#FF0000'})
        
        # TSB (Form) als Balken hinzuf√ºgen
        fig_perf.add_bar(x=daily_load.tail(90)['Date'], y=daily_load.tail(90)['TSB'], name='Form (TSB)', 
                         marker_color=daily_load.tail(90)['TSB'].apply(lambda x: 'rgba(0, 255, 255, 0.4)' if x >= 0 else 'rgba(255, 165, 0, 0.4)'))
        
        # FIX: width='stretch' statt use_container_width
        st.plotly_chart(fig_perf, width='stretch')
        
        # 4. Aktuelle Werte als Metriken
        c_m1, c_m2, c_m3 = st.columns(3)
        with c_m1:
            st.metric("Fitness (CTL)", round(curr_ctl, 1), help="Deine langfristige Belastbarkeit.")
        with c_m2:
            st.metric("Erm√ºdung (ATL)", round(curr_atl, 1), help="Deine kurzfristige Belastung.")
        with c_m3:
            tsb_state = "Frisch" if curr_tsb > 5 else ("Erm√ºdet" if curr_tsb < -20 else "Optimales Training")
            st.metric("Form (TSB)", round(curr_tsb, 1), delta=tsb_state, delta_color="normal" if curr_tsb > -20 else "inverse")

    st.divider()

    # --- ZIELE & FORTSCHRITT SEKTION ---
    st.header("üéØ Ziele & Fortschritt")
    
    col_t1, col_t2 = st.columns([1.6, 1])
    
    with col_t1:
        # VO2 Max Daten kommen aus der garmin_stats.csv
        if df_stats is not None:
            df_vo2 = df_stats.copy()
            df_vo2['Date'] = pd.to_datetime(df_vo2['Date'])
            vo2_col_name = "VO2 Max" 
            
            if vo2_col_name in df_vo2.columns:
                df_vo2[vo2_col_name] = pd.to_numeric(df_vo2[vo2_col_name], errors='coerce')
                df_vo2 = df_vo2.dropna(subset=[vo2_col_name])
                df_vo2 = df_vo2.sort_values('Date')
                
                if not df_vo2.empty:
                    fig_vo2 = px.line(df_vo2, x='Date', y=vo2_col_name, title="VO2Max Reise (seit 2020)",
                                      markers=True, color_discrete_sequence=['#FF69B4'])
                    fig_vo2.update_traces(line=dict(width=2), marker=dict(size=4))
                    fig_vo2.update_xaxes(range=["2020-01-01", datetime.now().strftime("%Y-%m-%d")],
                                         tickformat="%Y", dtick="M12", gridcolor='#333')
                    fig_vo2.update_layout(height=400, plot_bgcolor='rgba(0,0,0,0)', paper_bgcolor='rgba(0,0,0,0)',
                                          hovermode="x unified", yaxis_title="VO2 Max")
                    st.plotly_chart(fig_vo2, width='stretch')

    with col_t2:
        st.subheader("üöÄ Aktuelle Power-Sch√§tzung")
        # Hier nutzen wir jetzt den zentralen Wert 'est_ftp'
        st.metric("Gesch√§tzte FTP", f"{est_ftp} W", delta=f"{est_ftp - 230} W vs. Start")
        st.write("Basis: 95% deiner besten NP (letzte 30 Tage).")

    st.markdown("---")
    
    # --- DIE GROSSE GRAFISCHE FTP-WALL ---
    st.header("üèÅ Der Weg zur 250-Watt-Marke")
    
    target_ftp = 250
    start_point = 150 
    
    total_range = target_ftp - start_point
    current_progress = est_ftp - start_point
    progress_percent = min(max(current_progress / total_range, 0.0), 1.0)
    
    st.write(f"Dein aktueller Stand: **{est_ftp} Watt**")
    st.progress(progress_percent)
    
    c_s1, c_s2 = st.columns([1, 1])
    c_s1.caption(f"Basis: {start_point}W")
    c_s2.markdown(f"<p style='text-align: right; color: #00C853; font-size: 20px; font-weight: bold;'>Ziel: {target_ftp}W</p>", unsafe_allow_html=True)